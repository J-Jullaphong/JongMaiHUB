export class Schema {
    constructor(schema) {
        this.spec = schema;
    }
    getFieldType(fieldName) {
        var _a;
        return (_a = this.spec) === null || _a === void 0 ? void 0 : _a[fieldName];
    }
    getKeys() {
        return Object.keys(this.spec);
    }
    setSchemaOptionsForAllType(data) {
        if (data === this.data) {
            return;
        }
        Object.entries(this.spec).forEach(([key, type]) => {
            type.setSchemaOptions(this.spec, data === null || data === void 0 ? void 0 : data[key]);
        });
        this.data = data;
    }
    checkForField(fieldName, data) {
        this.setSchemaOptionsForAllType(data);
        const fieldChecker = this.spec[fieldName];
        if (!fieldChecker) {
            // fieldValue can be anything if no schema defined
            return { hasError: false };
        }
        return fieldChecker.check(data[fieldName], data, fieldName);
    }
    checkForFieldAsync(fieldName, data) {
        this.setSchemaOptionsForAllType(data);
        const fieldChecker = this.spec[fieldName];
        if (!fieldChecker) {
            // fieldValue can be anything if no schema defined
            return Promise.resolve({ hasError: false });
        }
        return fieldChecker.checkAsync(data[fieldName], data, fieldName);
    }
    check(data) {
        const checkResult = {};
        Object.keys(this.spec).forEach(key => {
            if (typeof data === 'object') {
                checkResult[key] = this.checkForField(key, data);
            }
        });
        return checkResult;
    }
    checkAsync(data) {
        const checkResult = {};
        const promises = [];
        const keys = [];
        Object.keys(this.spec).forEach((key) => {
            keys.push(key);
            promises.push(this.checkForFieldAsync(key, data));
        });
        return Promise.all(promises).then(values => {
            for (let i = 0; i < values.length; i += 1) {
                checkResult[keys[i]] = values[i];
            }
            return checkResult;
        });
    }
}
export function SchemaModel(o) {
    return new Schema(o);
}
SchemaModel.combine = function combine(...specs) {
    return new Schema(specs
        .map(model => model.spec)
        .reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));
};
//# sourceMappingURL=Schema.js.map