import { MixedType } from './MixedType';
export class ArrayType extends MixedType {
    constructor(errorMessage) {
        super('array');
        super.pushRule({
            onValid: v => Array.isArray(v),
            errorMessage: errorMessage || this.locale.type
        });
    }
    rangeLength(minLength, maxLength, errorMessage = this.locale.rangeLength) {
        super.pushRule({
            onValid: (value) => value.length >= minLength && value.length <= maxLength,
            errorMessage,
            params: { minLength, maxLength }
        });
        return this;
    }
    minLength(minLength, errorMessage = this.locale.minLength) {
        super.pushRule({
            onValid: value => value.length >= minLength,
            errorMessage,
            params: { minLength }
        });
        return this;
    }
    maxLength(maxLength, errorMessage = this.locale.maxLength) {
        super.pushRule({
            onValid: value => value.length <= maxLength,
            errorMessage,
            params: { maxLength }
        });
        return this;
    }
    unrepeatable(errorMessage = this.locale.unrepeatable) {
        super.pushRule({
            onValid: items => {
                const hash = {};
                for (const i in items) {
                    if (hash[items[i]]) {
                        return false;
                    }
                    hash[items[i]] = true;
                }
                return true;
            },
            errorMessage
        });
        return this;
    }
    of(type) {
        super.pushRule({
            onValid: (items, data, filedName) => {
                const checkResults = items.map((value, index) => {
                    const name = Array.isArray(filedName)
                        ? [...filedName, `[${index}]`]
                        : [filedName, `[${index}]`];
                    return type.check(value, data, name);
                });
                const hasError = !!checkResults.find(item => item === null || item === void 0 ? void 0 : item.hasError);
                return {
                    hasError,
                    array: checkResults
                };
            }
        });
        return this;
    }
}
export default function getArrayType(errorMessage) {
    return new ArrayType(errorMessage);
}
//# sourceMappingURL=ArrayType.js.map