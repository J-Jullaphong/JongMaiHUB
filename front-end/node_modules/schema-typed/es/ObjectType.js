import { MixedType } from './MixedType';
import { createValidator, createValidatorAsync, checkRequired, isEmpty } from './utils';
export class ObjectType extends MixedType {
    constructor(errorMessage) {
        super('object');
        super.pushRule({
            onValid: v => typeof v === 'object',
            errorMessage: errorMessage || this.locale.type
        });
    }
    check(value = this.value, data, fieldName) {
        const check = (value, data, type) => {
            if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {
                return { hasError: true, errorMessage: type.requiredMessage };
            }
            if (type.objectTypeSchemaSpec && typeof value === 'object') {
                const checkResultObject = {};
                let hasError = false;
                Object.entries(type.objectTypeSchemaSpec).forEach(([k, v]) => {
                    const checkResult = check(value[k], value, v);
                    if (checkResult === null || checkResult === void 0 ? void 0 : checkResult.hasError) {
                        hasError = true;
                    }
                    checkResultObject[k] = checkResult;
                });
                return { hasError, object: checkResultObject };
            }
            const validator = createValidator(data, fieldName);
            const checkStatus = validator(value, type.priorityRules);
            if (checkStatus) {
                return checkStatus;
            }
            if (!type.required && isEmpty(value)) {
                return { hasError: false };
            }
            return validator(value, type.rules) || { hasError: false };
        };
        return check(value, data, this);
    }
    checkAsync(value = this.value, data, fieldName) {
        const check = (value, data, type) => {
            if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {
                return Promise.resolve({ hasError: true, errorMessage: this.requiredMessage });
            }
            const validator = createValidatorAsync(data, fieldName);
            return new Promise(resolve => {
                if (type.objectTypeSchemaSpec && typeof value === 'object') {
                    const checkResult = {};
                    const checkAll = [];
                    const keys = [];
                    Object.entries(type.objectTypeSchemaSpec).forEach(([k, v]) => {
                        checkAll.push(check(value[k], value, v));
                        keys.push(k);
                    });
                    return Promise.all(checkAll).then(values => {
                        values.forEach((v, index) => {
                            checkResult[keys[index]] = v;
                        });
                        resolve({ object: checkResult });
                    });
                }
                return validator(value, type.priorityRules)
                    .then((checkStatus) => {
                    if (checkStatus) {
                        resolve(checkStatus);
                    }
                })
                    .then(() => {
                    if (!type.required && isEmpty(value)) {
                        resolve({ hasError: false });
                    }
                })
                    .then(() => validator(value, type.rules))
                    .then((checkStatus) => {
                    if (checkStatus) {
                        resolve(checkStatus);
                    }
                    resolve({ hasError: false });
                });
            });
        };
        return check(value, data, this);
    }
    /**
     * @example
     * ObjectType().shape({
     *  name: StringType(),
     *  age: NumberType()
     * })
     */
    shape(fields) {
        this.objectTypeSchemaSpec = fields;
        return this;
    }
}
export default function getObjectType(errorMessage) {
    return new ObjectType(errorMessage);
}
//# sourceMappingURL=ObjectType.js.map