import { checkRequired, createValidator, createValidatorAsync, isEmpty, formatErrorMessage } from './utils';
import locales from './locales';
export class MixedType {
    constructor(name) {
        this.required = false;
        this.requiredMessage = '';
        this.trim = false;
        this.emptyAllowed = false;
        this.rules = [];
        this.priorityRules = [];
        this.typeName = name;
        this.locale = Object.assign(name ? locales[name] : {}, locales.mixed);
    }
    setSchemaOptions(schemaSpec, value) {
        this.schemaSpec = schemaSpec;
        this.value = value;
    }
    check(value = this.value, data, fieldName) {
        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {
            return {
                hasError: true,
                errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })
            };
        }
        const validator = createValidator(data, fieldName);
        const checkStatus = validator(value, this.priorityRules);
        if (checkStatus) {
            return checkStatus;
        }
        if (!this.required && isEmpty(value)) {
            return { hasError: false };
        }
        return validator(value, this.rules) || { hasError: false };
    }
    checkAsync(value = this.value, data, fieldName) {
        if (this.required && !checkRequired(value, this.trim, this.emptyAllowed)) {
            return Promise.resolve({
                hasError: true,
                errorMessage: formatErrorMessage(this.requiredMessage, { name: fieldName })
            });
        }
        const validator = createValidatorAsync(data, fieldName);
        return new Promise(resolve => validator(value, this.priorityRules)
            .then((checkStatus) => {
            if (checkStatus) {
                resolve(checkStatus);
            }
        })
            .then(() => {
            if (!this.required && isEmpty(value)) {
                resolve({ hasError: false });
            }
        })
            .then(() => validator(value, this.rules))
            .then((checkStatus) => {
            if (checkStatus) {
                resolve(checkStatus);
            }
            resolve({ hasError: false });
        }));
    }
    pushRule(rule) {
        var _a, _b;
        const { onValid, errorMessage, priority, params } = rule;
        const nextRule = {
            onValid,
            params,
            isAsync: rule.isAsync,
            errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)
        };
        if (priority) {
            this.priorityRules.push(nextRule);
        }
        else {
            this.rules.push(nextRule);
        }
    }
    addRule(onValid, errorMessage, priority) {
        this.pushRule({ onValid, errorMessage, priority });
        return this;
    }
    addAsyncRule(onValid, errorMessage, priority) {
        this.pushRule({ onValid, isAsync: true, errorMessage, priority });
        return this;
    }
    isRequired(errorMessage = this.locale.isRequired, trim = true) {
        this.required = true;
        this.trim = trim;
        this.requiredMessage = errorMessage;
        return this;
    }
    isRequiredOrEmpty(errorMessage = this.locale.isRequiredOrEmpty, trim = true) {
        this.required = true;
        this.trim = trim;
        this.emptyAllowed = true;
        this.requiredMessage = errorMessage;
        return this;
    }
    /**
     * Define data verification rules based on conditions.
     * @param validator
     * @example
     * MixedType().when(schema => {
     *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);
     * });
     */
    when(condition) {
        this.addRule((value, data, filedName) => {
            return condition(this.schemaSpec).check(value, data, filedName);
        }, undefined, true);
        return this;
    }
}
export default function getMixedType() {
    return new MixedType();
}
//# sourceMappingURL=MixedType.js.map